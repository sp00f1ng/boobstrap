#! /usr/bin/env sh

do_error() {
	echo "$@" | sent_message --STDERR
}

do_panic() {
	do_error ""
	do_error "Interrupted"

	if test -d "$TMPDIR"; then
		rm -r -f "$TMPDIR"
	fi

	exit 1
}

do_export() {
	find . -print0 | cpio --create --format "newc" --null --quiet
}

do_import() {
	cpio --extract --make-directories --format "newc" --quiet
}

sent_message() {
	STDERR="-"
	STDOUT="+"
	INDENT=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--STDERR") STDERR="+" STDOUT="-" ;;
			"--STDOUT") STDERR="-" STDOUT="+" ;;
		esac
		shift
	done

	if test "$STDERR" = "+"; then
		while read -r MESSAGE; do
			echo "$INDENT$MESSAGE" >&2
		done
	fi

	if test "$STDOUT" = "+"; then
		while read -r MESSAGE; do
			echo "$INDENT$MESSAGE" >&1
		done
	fi
}

#
# Initial RAM Disk Section: Build initramfs
#

ramdisk() {
	INSTALL_PATH=""
	IMAGE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--image") IMAGE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1" | sent_message
				;;
			*)
				if test "$INSTALL_PATH" = ""; then
					INSTALL_PATH="$1"
				fi
				;;
		esac
		shift
	done

	if test "$INSTALL_PATH"; then
		if test -d "$INSTALL_PATH"; then
			ROOT="$(realpath $INSTALL_PATH)"
		else
			echo "No such directory: $INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		ROOT="$(mktemp --directory --quiet ramdisk-XXXXXXXXXX)"
		ROOT="$(realpath $ROOT)"
	fi

	if test "$IMAGE"; then
		IMAGE="$(realpath $IMAGE)"
	else
		echo "Image not specified, add --image <file> for initramfs image" | sent_message --STDERR
		return 1
	fi

	ramdisk_make_directories "$ROOT"

	ramdisk_make_devices "$ROOT"

	ramdisk_make_binaries "$ROOT"

	ramdisk_init_script "$ROOT"

	cd "$ROOT"

	do_export > "$IMAGE"
	
	cd "$OLDPWD"

	return 0
}

ramdisk_init_script() {
	cat >> "$1/init" <<"EOF"
#! /usr/bin/env sh

exec sh

# End of file
EOF

	chmod +x "$1/init"
}

ramdisk_make_directories() {
	for dir in "/proc" "/sys" "/dev" "/run" "/sbin" "/bin" "/etc" "/usr/sbin" "/usr/bin" "/mnt" "/tmp"; do
		mkdir -p "$1/$dir" || return 1
	done
	
	unset dir
	
	return 0
}

ramdisk_make_devices() {
	for dev in "console" "tty" "tty1" "null"; do
		cp -a "/dev/$dev" "$1/dev/$dev" || return 1
	done

	return 0
}

lddtree() {
	if test "$1" = ""; then
		return 0
	fi
	
	echo "$1"
	
	for dep in $(ldd "$1" | awk 'BEGIN{ORS="\n"}$1~/^\//{print $1}$3~/^\//{print $3}'); do
		lddtree "$dep"
	done
	
	unset dep
}

ramdisk_make_binaries() {
	for exe in "sh" "env" "switch_root" "mount" "umount" "mkdir" "rmdir" "cp" "mv" "rm" "mknod" "cpio" "sleep"; do
		LOCATE_EXE="$(which $exe)"

		if test "$LOCATE_EXE"; then
			LOCATE_DEP=""

			for dep in $(lddtree $LOCATE_EXE); do
				LOCATE_DEP="$LOCATE_DEP $dep"

				if test -f "$1/$dep"; then
					continue
				fi

				install -D "$dep" "$1/$dep" || return 1
			done

			unset dep
		fi
	done

	return 0
}

#
# Linux Section: Download & Build
#

download() {
	URL="$1"
	DIRECTORY="$2"
	FILE="$3"
	APPEND=""

	if test -f "$DIRECTORY/$FILE.part"; then
		APPEND="--continue"
	fi

	wget --timeout 5 --output-document="$DIRECTORY/$FILE.part" $APPEND --quiet "$URL" || return 1

	mv "$DIRECTORY/$FILE.part" "$DIRECTORY/$FILE" || return 1

	unset URL
	unset DIRECTORY
	unset FILE
	unset APPEND

	return 0
}

extract() {
	ROOT="$1"
	DIRECTORY="$2"
	FILE="$3"

	tar --get --file="$DIRECTORY/$FILE" --directory="$ROOT" || return 1

	unset ROOT
	unset DIRECTORY
	unset FILE

	return 0
}

linux() {
	KERNEL_NAME=""
	KERNEL_VERSION=""
	KERNEL_RELEASE=""
	CONFIG_FILE=""
	INSTALL_PATH=""
	FORCE=""
	CACHE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") KERNEL_RELEASE="$2" ; shift ;;
			"--config-file") CONFIG_FILE="$2" ; shift ;;
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--force") FORCE="+" ;;
			"--cache") CACHE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1" | sent_message
				;;
			*)
				if test "$KERNEL_VERSION" = ""; then
					KERNEL_VERSION="$1"
				elif test "$KERNEL_RELEASE" = ""; then
					KERNEL_RELEASE="$1"
				fi
				;;
		esac
		shift
	done

	if test "$KERNEL_NAME" = ""; then
		KERNEL_NAME="linux"
	fi

	if test "$KERNEL_VERSION" = ""; then
		KERNEL_VERSION=""
	fi

	if test "$KERNEL_RELEASE" = ""; then
		KERNEL_RELEASE="1"
	fi

	if test "$FORCE"; then
		__FORCE_DOWNLOAD="--force-download"
		__FORCE_REBUILD="--force-rebuild"
	else
		__FORCE_DOWNLOAD=""
		__FORCE_REBUILD=""
	fi

	echo "Looking up for $KERNEL_NAME" | sent_message

	linux_via_http "$KERNEL_VERSION"           \
		$__FORCE_DOWNLOAD                  \
		--kernel-name "$KERNEL_NAME"       \
		--kernel-version "$KERNEL_VERSION" \
		--kernel-release "$KERNEL_RELEASE" \
		--cache "$CACHE"

	if test -d "$KERNEL_SOURCE"; then

		linux_build "$KERNEL_SOURCE"               \
			$__FORCE_REBUILD                   \
			--kernel-name "$KERNEL_NAME"       \
			--kernel-version "$KERNEL_VERSION" \
			--kernel-release "$KERNEL_RELEASE" \
			--config-file "$CONFIG_FILE"       \
			--install-path "$INSTALL_PATH"     \
			--cache "$CACHE"

	else

		return 1

	fi

	if test -d "$INSTALL_ROOT"; then

		echo ...

	fi

	return 0
}

linux_build() {
	KERNEL_NAME=""
	KERNEL_VERSION=""
	KERNEL_RELEASE=""
	KERNEL_SOURCE=""
	CONFIG_FILE=""
	INSTALL_PATH=""
	FORCE_REBUILD=""
	CACHE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") KERNEL_RELEASE="$2" ; shift ;;
			"--config-file") CONFIG_FILE="$2" ; shift ;;
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--cache") CACHE="$2" ; shift ;;
			"--force-rebuild") FORCE_REBUILD="+" ;;
			"-"*) echo "invalid option $1" ;;
			*)
				if test "$KERNEL_SOURCE" = ""; then
					KERNEL_SOURCE="$1"
				fi
				;;
		esac
		shift
	done

	if test "$INSTALL_PATH"; then
		if test -d "$INSTALL_PATH"; then
			ROOT="$(realpath $INSTALL_PATH)"
		else
			echo "No such directory: $INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		ROOT="$(mktemp --directory --quiet root-XXXXXXXXXX)"
		ROOT="$(realpath $ROOT)"
	fi

	echo "Build [$KERNEL_SOURCE]" | sent_message

	cd "$KERNEL_SOURCE"

	make allnoconfig

	make -j $(($(nproc) + 1))

	install -D "arch/x86/boot/bzImage" "$ROOT/boot/bzImage"
	
	echo "$KERNEL_NAME $KERNEL_VERSION installed [$ROOT]" | sent_message

	return 0
}

linux_via_git() {
	return 255
}

linux_via_http() {
	KERNEL_NAME=""
	KERNEL_VERSION=""
	KERNEL_RELEASE=""
	KERNEL_SOURCE=""
	SOURCE_DIRECTORY=""
	FORCE_DOWNLOAD=""
	CACHE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") KERNEL_RELEASE="$2" ; shift ;;
			"--source-directory"|"-s") SOURCE_DIRECTORY="$2" ; shift ;;
			"--force-download"|"-f") FORCE_DOWNLOAD="yes" ;;
			"--cache"|"-c") CACHE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1"
				return 1
				;;
			*)
				if test "$KERNEL_VERSION" = ""; then
					KERNEL_VERSION="$1"
				fi
				;;
		esac
		shift
	done

	if test "$KERNEL_VERSION" = ""; then
		KERNEL_VERSION=$(wget --timeout 5 --output-document - --quiet www.kernel.org | grep -A 1 latest_link)
		KERNEL_VERSION=${KERNEL_VERSION##*.tar.xz\">}
		KERNEL_VERSION=${KERNEL_VERSION%</a>*}
	else
		KERNEL_VERSION="$KERNEL_VERSION"
	fi

	case "$KERNEL_VERSION" in
		[0-9]*.[0-9]*.0) KERNEL_VERSION="${KERNEL_VERSION%.*}" ;;
		[0-9]*.[0-9]*.[0-9]*) ;;
		*)
			echo "kernel.org was hacked or invalid version: $KERNEL_VERSION"
			return 1
			;;
	esac

	if test -d "$SOURCE_DIRECTORY"; then
		echo noop
	else
		SOURCE_DIRECTORY="$(pwd)"
	fi

	LOCAL_DIRECTORY="$SOURCE_DIRECTORY"
	LOCAL_FILE="linux-$KERNEL_VERSION.tar.xz"

	REMOTE_DIRECTORY="/pub/linux/kernel/v${KERNEL_VERSION%%.*}.x"
	REMOTE_FILE="linux-$KERNEL_VERSION.tar.xz"

	URL="https://cdn.kernel.org$REMOTE_DIRECTORY/$REMOTE_FILE"
	KERNEL_SOURCE="$LOCAL_DIRECTORY/linux-$KERNEL_VERSION"

	if test "$FORCE_DOWNLOAD"; then

		if test -f "$LOCAL_DIRECTORY/$LOCAL_FILE"; then
			rm -r -f "$LOCAL_DIRECTORY/$LOCAL_FILE"
		fi

		if test -f "$LOCAL_DIRECTORY/$LOCAL_FILE.part"; then
			rm -r -f "$LOCAL_DIRECTORY/$LOCAL_FILE.part"
		fi

		if test -d "$KERNEL_SOURCE"; then
			rm -r -f "$KERNEL_SOURCE"
		fi

		if test -d "$CACHE"; then
			rm -r -f "$CACHE/$LOCAL_FILE"
		fi

	fi

	if test -d "$KERNEL_SOURCE"; then

		echo "Source [$KERNEL_SOURCE]" | sent_message

	elif test -f "$CACHE/$LOCAL_FILE"; then

		echo "Extracting... [$CACHE/$LOCAL_FILE]" | sent_message

		extract "$LOCAL_DIRECTORY" "$CACHE" "$LOCAL_FILE" || return 1

		echo "Source [$KERNEL_SOURCE]" | sent_message

	else

		echo "Downloading... [$URL]" | sent_message

		download "$URL" "$LOCAL_DIRECTORY" "$LOCAL_FILE" || return 1

		echo "Extracting... [$LOCAL_DIRECTORY/$LOCAL_FILE]" | sent_message

		extract "$LOCAL_DIRECTORY" "$LOCAL_DIRECTORY" "$LOCAL_FILE" || return 1

		if test -d "$CACHE"; then

			echo "Caching... [$CACHE/$LOCAL_FILE]" | sent_message

			cp "$LOCAL_DIRECTORY/$LOCAL_FILE" "$CACHE/$LOCAL_FILE"

		fi

		echo "Source [$KERNEL_SOURCE]" | sent_message

	fi

	return 0
}

#
# Main Section: Application Data
#

booty() {
	PROFILE=""
	CACHE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"-p"|"--profile") PROFILE="$2" ; shift ;;
			"-c"|"--cache") CACHE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1" | sent_message
				return 1
				;;
			*)
				echo "invalid option $1" | sent_message
				return 1
				;;
		esac
	done

	# set $TMPDIR by `mktemp` for future use
	TMPDIR="$(pwd)"
	TMPDIR="$(mktemp --directory --quiet $BOOTY_NAME-XXX)"
	TMPDIR="$(realpath $TMPDIR)"

	ROOT="$(mktemp --directory --quiet root-XXXXXXXXXX)"
	BOOT="$(mktemp --directory --quiet boot-XXXXXXXXXX)"

	linux --install-path "$ROOT"

	ramdisk --install-path "$ROOT" --image "$ROOT/boot/INITRD.IMG"

	mv "$ROOT/boot" "$BOOT/boot"

	boot --install-path "$BOOT" --image "$TMPDIR/BOOT-$(uname -m).ISO"

	echo rm -r -f "$TMPDIR"
}

main() {
	case "$1" in
		"import") shift ; do_import $@ ;;
		"export") shift ; do_export $@ ;;
		"linux") shift ; linux $@ ;;
		"linux_via_http") shift ; linux_via_http $@ ;;
		"linux_via_git") shift ; linux_via_git $@ ;;
		"linux_build") shift ; linux_build $@ ;;
		"ramdisk") shift ; ramdisk $@ ;;
		*) booty $@ ;;
	esac
}

show_help() {
	cat <<EOF
$BOOTY_NAME $BOOTY_VERSION

Usage: booty <directory> [directory]... <bootable image> [options]...

Creates BIOS and/or UEFI compatible bootable images
with operating system from specified directory.

  -p, --profile <profile>    Creates bootable image with pre-defined options

                             Profiles:
                               initramfs [default]
                               overlayfs

  -c, --cache <directory>    Storage for data like a binary kernels, sources
                             and so on to prevent download it and building
                             the same things again and again

  --kernel-version <version>,    Select kernel version to build and/or label
  --kernel-release <release>     for cache data.

  -v, --verbose              Verbosity level can be increased by multiples -vvvvv

  --help                     Show this help

Report about bugs & features to $(echo c3Bvb2ZpbmdAdm9nbGVhLm5ldAo= | base64 -d)
EOF
}

trap "do_panic" HUP INT QUIT TERM

readonly BOOTY_NAME="booty"
readonly BOOTY_VERSION="2.0"

unset TMPDIR

main "$@"
