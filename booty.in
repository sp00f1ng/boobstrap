#! /usr/bin/env sh

do_error() {
	echo "$@" | sent_message --STDERR
}

do_panic() {
	do_error ""
	do_error "Interrupted"

	main_exit 1
}

do_import() {
	cpio --extract --make-directories --format "newc" --quiet
}

do_export() {
	find . -print0 | cpio --create --format "newc" --null --quiet
}

sent_message() {
	STDERR="-"
	STDOUT="+"
	INDENT=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--STDERR") STDERR="+" STDOUT="-" ;;
			"--STDOUT") STDERR="-" STDOUT="+" ;;
		esac
		shift
	done

	if test "$STDERR" = "+"; then
		while read -r MESSAGE; do
			echo "$INDENT$MESSAGE" >&2
		done
	fi

	if test "$STDOUT" = "+"; then
		while read -r MESSAGE; do
			echo "$INDENT$MESSAGE" >&1
		done
	fi
}

#
# Image Section: Bootable image
#
image() {
	INSTALL_PATH=""
	IMAGE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--image") IMAGE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1" | sent_message
				;;
			*)
				if test "$INSTALL_PATH" = ""; then
					INSTALL_PATH="$1"
				else
					break
				fi
				;;
		esac
		shift
	done

	if test "$IMAGE"; then
		IMAGE="$(realpath $IMAGE)"
	else
		echo "Image not specified, add --image <file> for initramfs image" | sent_message --STDERR
		return 1
	fi

	if test "$INSTALL_PATH"; then
		if test -d "$INSTALL_PATH"; then
			INSTALL_PATH="$(realpath $INSTALL_PATH)"
		else
			echo "No such directory: $INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		INSTALL_PATH="$(mktemp --directory --quiet image-XXXXXXXXXX)"
		INSTALL_PATH="$(realpath $INSTALL_PATH)"
	fi

	while ! test "$#" = "0"; do
		SOURCE="${1%%=*}"
		DESTINATION="${1##*=}"
		if test -f "$SOURCE"; then
			if install -D "$SOURCE" "$INSTALL_PATH/$DESTINATION"; then
				echo "[$SOURCE] [$INSTALL_PATH/$DESTINATION]" | sent_message
			fi
		fi
		shift
	done

	echo "Install bootloader" | sent_message

	image_install_bootloader "$INSTALL_PATH"

	echo "Generate ISO 9660" | sent_message

	image_generate_iso9660 "$INSTALL_PATH" "$IMAGE"
}

image_install_bootloader() {
	INSTALL_PATH="$1"

	image_search_bootloader

	image_install_grub2 "$INSTALL_PATH"
}

image_install_grub2() {
	INSTALL_PATH="$1"

	install -d "$INSTALL_PATH/boot"
	install -d "$INSTALL_PATH/boot/grub"

	cat > "$INSTALL_PATH/boot/grub/grub.cfg" <<EOF
search --file --no-floppy --set root /boot/vmlinuz
EOF

	install -d "$INSTALL_PATH/boot/grub/i386-pc"

	cp -a "$GRUB_BIOS_DATA/"*".mod" "$INSTALL_PATH/boot/grub/i386-pc"
	cp -a "$GRUB_BIOS_DATA/"*".lst" "$INSTALL_PATH/boot/grub/i386-pc"

	grub-mkimage                                        \
		                                            \
		--config="$INSTALL_PATH/boot/grub/grub.cfg" \
		--output="$INSTALL_PATH/boot/grub/core.img" \
		--format="i386-pc"                          \
		--prefix="/boot/grub"                       \
		                                            \
		"biosdisk" "iso9660" "normal" "search"      \
		"search_fs_file" "part_msdos" "part_gpt"    \
		"fat"

	cat "$GRUB_BIOS_DATA/cdboot.img" "$INSTALL_PATH/boot/grub/core.img" > "$INSTALL_PATH/boot/grub/bios.img"

	if ! test "$(id --user)" = "0"; then
		echo "You must be root to install EFI bootloader" | sent_message

		return 0
	fi

	install -d "$INSTALL_PATH/efi/boot"
	install -d "$INSTALL_PATH/boot/grub/i386-efi"
	install -d "$INSTALL_PATH/boot/grub/x86_64-efi"

	cp -a "$GRUB_EFI_LEGACY_DATA/"*".mod" "$INSTALL_PATH/boot/grub/i386-efi"
	cp -a "$GRUB_EFI_LEGACY_DATA/"*".lst" "$INSTALL_PATH/boot/grub/i386-efi"

	cp -a "$GRUB_EFI_DATA/"*".mod" "$INSTALL_PATH/boot/grub/x86_64-efi"
	cp -a "$GRUB_EFI_DATA/"*".lst" "$INSTALL_PATH/boot/grub/x86_64-efi"

	grub-mkimage                                           \
		                                               \
		--config="$INSTALL_PATH/boot/grub/grub.cfg"    \
		--output="$INSTALL_PATH/efi/boot/bootia32.efi" \
		--format="i386-efi"                            \
		--prefix="/boot/grub"                          \
		                                               \
		"iso9660" "normal" "search" "search_fs_file"   \
		"part_msdos" "part_gpt" "fat"

	grub-mkimage                                          \
		                                              \
		--config="$INSTALL_PATH/boot/grub/grub.cfg"   \
		--output="$INSTALL_PATH/efi/boot/bootx64.efi" \
		--format="x86_64-efi"                         \
		--prefix="/boot/grub"                         \
		                                              \
		"iso9660" "normal" "search" "search_fs_file"  \
		"part_msdos" "part_gpt" "fat"

	mkdosfs -C "$INSTALL_PATH/efi/boot/floppy.img" 1440

	mount -o loop "$INSTALL_PATH/efi/boot/floppy.img" "$INSTALL_PATH/boot"
	
	mkdir -p "$INSTALL_PATH/boot/efi/boot"
	
	cp "$INSTALL_PATH/efi/boot/bootx64.efi" "$INSTALL_PATH/boot/efi/boot"
	
	cp "$INSTALL_PATH/efi/boot/bootia32.efi" "$INSTALL_PATH/boot/efi/boot"
	
	umount "$INSTALL_PATH/boot"

	cat > "$INSTALL_PATH/boot/grub/grub.cfg" <<"EOF"
set default=2

function load_video {
	if [ x$feature_all_video_module = xy ]; then
		insmod all_video
	else
		insmod efi_gop
		insmod efi_uga
		insmod ieee1275_fb
		insmod vbe
		insmod vga
		insmod video_bochs
		insmod video_cirrus
	fi
}

if loadfont "unicode"; then
	set gfxmode=auto
	load_video
	insmod gfxterm
	if [ -f "$prefix/themes/default/theme.txt" ]; then
		insmod png
		set theme=$prefix/themes/default/theme.txt
	fi
fi
terminal_output gfxterm

if [ x$feature_timeout_style = xy ]; then
	set timeout_style=menu
	set timeout=3
else
	set timeout=3
fi

menuentry "Run GNU/Linux in Live-mode" {
	linux /boot/vmlinuz quiet
	initrd /boot/initrd
}
menuentry "Boot using SHMFS (default boot)" {
	linux /boot/vmlinuz booty.use-shmfs quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS" {
	linux /boot/vmlinuz booty.use-overlayfs quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Copy to RAM and release storage device)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.copy-to-ram quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Try to find /filesystem.squashfs)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.search-rootfs=/filesystem.squashfs quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Use /dev/sda as rootfs)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.search-rootfs=/dev/sda quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Use /dev/sda for data)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.rootfs-changes=/dev/sda quiet
	initrd /boot/initrd
}
EOF
}

image_install_syslinux() {
	# TODO syslinux
	# FIXME syslinux: legacy boot + gpt is just broken on ~May 2020
	return 1
}

image_search_bootloader() {
	for dir in "/usr/lib/grub" "/lib/grub"; do
		if test -d "$dir/i386-pc"; then
			GRUB_BIOS_DATA="$dir/i386-pc"
		fi
		if test -d "$dir/i386-efi"; then
			GRUB_EFI_LEGACY_DATA="$dir/i386-efi"
		fi
		if test -d "$dir/x86_64-efi"; then
			GRUB_EFI_DATA="$dir/x86_64-efi"
		fi
	done
	for dir in "/usr/share/syslinux" "/usr/lib/syslinux/bios"; do
		if test -f "$dir/mbr.bin"; then
			SYSLINUX_BIOS_MBR="$dir/mbr.bin"
		fi
		if test -f "$dir/gptmbr.bin"; then
			SYSLINUX_BIOS_GPTMBR="$dir/gptmbr.bin"
		fi
		if test -f "$dir/isolinux.bin"; then
			SYSLINUX_BIOS_ISOLINUX="$dir/isolinux.bin"
		fi
		if test -f "$dir/ldlinux.c32"; then
			SYSLINUX_BIOS_LDLINUX="$dir/ldlinux.c32"
		fi
	done
	for dir in "/usr/share/syslinux/efi64" "/usr/lib/syslinux/efi64"; do
		if test -f "$dir/syslinux.efi"; then
			SYSLINUX_UEFI_EFIBOOT="$dir/syslinux.efi"
		fi
		if test -f "$dir/ldlinux.e64"; then
			SYSLINUX_UEFI_LDLINUX="$dir/ldlinux.e64"
		fi
	done
	unset dir
}

image_generate_iso9660() {
	INSTALL_PATH="$1"
	IMAGE="$2"
	COMMAND=""

	if test "$COMMAND" = ""; then
		if command -v "xorrisofs"; then
			COMMAND="xorrisofs"
		fi

		if command -v "genisoimage"; then
			COMMAND="genisoimage"
		fi
	else
		echo "Install one: cdrkit, xorriso, mkisofs" | sent_message
		return 1
	fi

	if test "$COMMAND" = "genisoimage"; then
		genisoimage -v -J -r -V "BOOT-$(uname -m)" -A "BOOT-$(uname -m)" \
			-input-charset "utf-8" \
			-b "boot/grub/bios.img" -no-emul-boot -boot-load-size 4 -boot-info-table \
			-eltorito-alt-boot -e "efi/boot/floppy.img" -no-emul-boot \
			-o "$IMAGE" "$INSTALL_PATH"
	fi

	if test "$COMMAND" = "xorrisofs"; then
		# TODO
		return 1
	fi
	return 0
}

#
# Initial RAM Disk Section: Build initramfs
#

ramdisk() {
	INSTALL_PATH=""
	IMAGE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--image") IMAGE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1" | sent_message
				;;
			*)
				if test "$INSTALL_PATH" = ""; then
					INSTALL_PATH="$1"
				fi
				;;
		esac
		shift
	done

	if test "$IMAGE"; then
		IMAGE="$(realpath $IMAGE)"
	else
		echo "Image not specified, add --image <file> for initramfs image" | sent_message --STDERR
		return 1
	fi

	if test "$INSTALL_PATH"; then
		if test -d "$INSTALL_PATH"; then
			ROOT="$(realpath $INSTALL_PATH)"
		else
			echo "No such directory: $INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		ROOT="$(mktemp --directory --quiet ramdisk-XXXXXXXXXX)"
		ROOT="$(realpath $ROOT)"
	fi

	ramdisk_make_directories "$ROOT"

	ramdisk_make_devices "$ROOT"

	ramdisk_make_binaries "$ROOT"

	install -D -m 0755 "/usr/share/booty/init.rc" "$ROOT/init"

	cd "$ROOT"

	do_export > "$IMAGE"
	
	cd "$OLDPWD"

	return 0
}

ramdisk_make_directories() {
	for dir in "/proc" "/sys" "/dev" "/run" "/sbin" "/bin" "/etc" "/usr/sbin" "/usr/bin" "/mnt" "/tmp"; do
		mkdir -p "$1/$dir" || return 1
	done
	
	unset dir
	
	return 0
}

ramdisk_make_devices() {
	for dev in "console" "tty" "tty1" "null"; do
		cp -a "/dev/$dev" "$1/dev/$dev" || return 1
	done

	return 0
}

lddtree() {
	if test "$1" = ""; then
		return 0
	fi
	
	echo "$1"
	
	for dep in $(ldd "$1" | awk 'BEGIN{ORS="\n"}$1~/^\//{print $1}$3~/^\//{print $3}'); do
		lddtree "$dep"
	done
	
	unset dep
}

ramdisk_make_binaries() {
	for exe in "sh" "env" "switch_root" "mount" "umount" "mkdir" "rmdir" "cp" "mv" "rm" "mknod" "cpio" "sleep"; do
		LOCATE_EXE="$(which $exe)"

		if test "$LOCATE_EXE"; then
			LOCATE_DEP=""

			for dep in $(lddtree $LOCATE_EXE); do
				LOCATE_DEP="$LOCATE_DEP $dep"

				if test -f "$1/$dep"; then
					continue
				fi

				install -D "$dep" "$1/$dep" || return 1
			done

			unset dep
		fi
	done

	return 0
}

#
# Linux Section: Download & Build
#

download() {
	URL="$1"
	DIRECTORY="$2"
	FILE="$3"
	APPEND=""

	if test -f "$DIRECTORY/$FILE.part"; then
		APPEND="--continue"
	fi

	wget --timeout 5 --output-document="$DIRECTORY/$FILE.part" $APPEND --quiet "$URL" || return 1

	mv "$DIRECTORY/$FILE.part" "$DIRECTORY/$FILE" || return 1

	unset URL
	unset DIRECTORY
	unset FILE
	unset APPEND

	return 0
}

extract() {
	ROOT="$1"
	DIRECTORY="$2"
	FILE="$3"

	if ! test -d "$ROOT"; then
		return 1
	fi

	if ! test -d "$DIRECTORY"; then
		return 1
	fi

	if ! test -f "$DIRECTORY/$FILE"; then
		return 1
	fi

	if ! tar --get --file="$DIRECTORY/$FILE" --directory="$ROOT"; then
		return 1
	fi

	unset ROOT
	unset DIRECTORY
	unset FILE

	return 0
}

linux() {
	KERNEL_NAME=""
	KERNEL_VERSION=""
	KERNEL_RELEASE=""
	CONFIG_FILE=""
	INSTALL_PATH=""
	CACHE=""
	FORCE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") KERNEL_RELEASE="$2" ; shift ;;
			"--config-file") CONFIG_FILE="$2" ; shift ;;
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--cache") CACHE="$2" ; shift ;;
			"--force") FORCE="+" ;;
			"-"*)
				echo "invalid option $1" | sent_message --STDERR
				return 1
				;;
			*)
				if test "$KERNEL_VERSION" = ""; then
					KERNEL_VERSION="$1"
				elif test "$KERNEL_RELEASE" = ""; then
					KERNEL_RELEASE="$1"
				fi
				;;
		esac
		shift
	done

	if test "$KERNEL_NAME" = ""; then
		KERNEL_NAME="linux"
	fi
	if test "$KERNEL_VERSION" = ""; then
		KERNEL_VERSION=""
	fi
	if test "$KERNEL_RELEASE" = ""; then
		KERNEL_RELEASE="1"
	fi

	if test "$CONFIG_FILE"; then
		if test -f "$CONFIG_FILE"; then
			CONFIG_FILE="$(realpath $CONFIG_FILE)"
		else
			echo "No such file: $CONFIG_FILE" | sent_message --STDERR
			return 1
		fi
	fi

	if test "$CACHE"; then
		if test -d "$CACHE"; then
			CACHE="$(realpath $CACHE)"
		else
			echo "No such directory: $CACHE" | sent_message --STDERR
			return 1
		fi
	fi

	if test "$INSTALL_PATH"; then
		if test -d "$INSTALL_PATH"; then
			INSTALL_PATH="$(realpath $INSTALL_PATH)"
		else
			echo "No such directory: $INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		INSTALL_PATH="$(mktemp --directory --quiet root-XXXXXXXXXX)"
		INSTALL_PATH="$(realpath $INSTALL_PATH)"
	fi

	if test "$FORCE"; then
		__FORCE_DOWNLOAD="--force-download"
		__FORCE_REBUILD="--force-rebuild"
	else
		BUILD="$KERNEL_NAME-$KERNEL_RELEASE#$KERNEL_VERSION.pkg.tar"

		if test -f "$CACHE/$BUILD"; then
			echo "Cache for $KERNEL_NAME available" | sent_message
			if extract "$INSTALL_PATH" "$CACHE" "$BUILD"; then
				echo "Install $KERNEL_NAME from cache" | sent_message
				return 0
			else
				echo "Install $KERNEL_NAME from cache fails, continue" | sent_message
			fi

		fi

		__FORCE_DOWNLOAD=""
		__FORCE_REBUILD=""
	fi

	echo "Looking up for $KERNEL_NAME" | sent_message

	linux_via_http "$KERNEL_VERSION"           \
		$__FORCE_DOWNLOAD                  \
		--kernel-name "$KERNEL_NAME"       \
		--kernel-version "$KERNEL_VERSION" \
		--kernel-release "$KERNEL_RELEASE" \
		--cache "$CACHE"

	if test -d "$KERNEL_SOURCE"; then

		linux_build "$KERNEL_SOURCE"               \
			$__FORCE_REBUILD                   \
			--kernel-name "$KERNEL_NAME"       \
			--kernel-version "$KERNEL_VERSION" \
			--kernel-release "$KERNEL_RELEASE" \
			--config-file "$CONFIG_FILE"       \
			--install-path "$INSTALL_PATH"

	else
		return 1
	fi

	if test -d "$CACHE"; then
		BUILD="$KERNEL_NAME-$KERNEL_RELEASE#$KERNEL_VERSION.pkg.tar"

		if tar --create --file="$CACHE/$BUILD" --directory="$INSTALL_PATH" .; then
			echo "Cached [$CACHE/$BUILD]" | sent_message
		else
			echo "Cache failed [$CACHE/$BUILD]" | sent_message
		fi
	fi

	return 0
}

linux_build() {
	KERNEL_NAME=""
	KERNEL_VERSION=""
	KERNEL_RELEASE=""
	KERNEL_SOURCE=""
	CONFIG_FILE=""
	INSTALL_PATH=""
	FORCE_REBUILD=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") KERNEL_RELEASE="$2" ; shift ;;
			"--config-file") CONFIG_FILE="$2" ; shift ;;
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--force-rebuild") FORCE_REBUILD="+" ;;
			"-"*) echo "invalid option $1" ;;
			*)
				if test "$KERNEL_SOURCE" = ""; then
					KERNEL_SOURCE="$1"
				fi
				;;
		esac
		shift
	done

	echo "Build [$KERNEL_SOURCE]" | sent_message

	cd "$KERNEL_SOURCE"

	make defconfig

	make kvm_guest.config

	# SquashFS + OverlayFS
	scripts/config -e OVERLAY_FS

	scripts/config -e SQUASHFS
	scripts/config -e SQUASHFS_XZ

	make olddefconfig

	make -j $(($(nproc) + 1))

	make INSTALL_MOD_PATH="$INSTALL_PATH" modules_install

	install -D "arch/x86/boot/bzImage" "$INSTALL_PATH/boot/bzImage"

	echo "Install $KERNEL_NAME $KERNEL_VERSION [$INSTALL_PATH]" | sent_message

	return 0
}

linux_via_git() {
	return 255
}

linux_via_http() {
	KERNEL_NAME=""
	KERNEL_VERSION=""
	KERNEL_RELEASE=""
	KERNEL_SOURCE=""
	SOURCE_DIRECTORY=""
	FORCE_DOWNLOAD=""
	CACHE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") KERNEL_RELEASE="$2" ; shift ;;
			"--source-directory"|"-s") SOURCE_DIRECTORY="$2" ; shift ;;
			"--force-download"|"-f") FORCE_DOWNLOAD="yes" ;;
			"--cache"|"-c") CACHE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1"
				return 1
				;;
			*)
				if test "$KERNEL_VERSION" = ""; then
					KERNEL_VERSION="$1"
				fi
				;;
		esac
		shift
	done

	if test "$KERNEL_VERSION" = ""; then
		KERNEL_VERSION=$(wget --timeout 5 --output-document - --quiet www.kernel.org | grep -A 1 latest_link)
		KERNEL_VERSION=${KERNEL_VERSION##*.tar.xz\">}
		KERNEL_VERSION=${KERNEL_VERSION%</a>*}
	fi

	case "$KERNEL_VERSION" in
		[0-9]*.[0-9]*.0) KERNEL_VERSION="${KERNEL_VERSION%.*}" ;;
		[0-9]*.[0-9]*.[0-9]*) ;;
		*)
			echo "kernel.org was hacked or invalid version: $KERNEL_VERSION"
			return 1
			;;
	esac

	if test -d "$SOURCE_DIRECTORY"; then
		echo noop
	else
		SOURCE_DIRECTORY="$(pwd)"
	fi

	LOCAL_DIRECTORY="$SOURCE_DIRECTORY"
	LOCAL_FILE="linux-$KERNEL_VERSION.tar.xz"

	REMOTE_DIRECTORY="/pub/linux/kernel/v${KERNEL_VERSION%%.*}.x"
	REMOTE_FILE="linux-$KERNEL_VERSION.tar.xz"

	URL="https://cdn.kernel.org$REMOTE_DIRECTORY/$REMOTE_FILE"
	KERNEL_SOURCE="$LOCAL_DIRECTORY/linux-$KERNEL_VERSION"

	# TODO
	#if test "$FORCE_DOWNLOAD"; then
	#fi

	if test -d "$KERNEL_SOURCE"; then

		echo "Source [$KERNEL_SOURCE]" | sent_message

	elif test -f "$CACHE/$LOCAL_FILE"; then

		echo "Extracting... [$CACHE/$LOCAL_FILE]" | sent_message

		extract "$LOCAL_DIRECTORY" "$CACHE" "$LOCAL_FILE" || return 1

		echo "Source [$KERNEL_SOURCE]" | sent_message

	else

		echo "Downloading... [$URL]" | sent_message

		download "$URL" "$LOCAL_DIRECTORY" "$LOCAL_FILE" || return 1

		echo "Extracting... [$LOCAL_DIRECTORY/$LOCAL_FILE]" | sent_message

		extract "$LOCAL_DIRECTORY" "$LOCAL_DIRECTORY" "$LOCAL_FILE" || return 1

		if test -d "$CACHE"; then

			echo "Cached... [$CACHE/$LOCAL_FILE]" | sent_message

			cp "$LOCAL_DIRECTORY/$LOCAL_FILE" "$CACHE/$LOCAL_FILE"

		fi

		echo "Source [$KERNEL_SOURCE]" | sent_message

	fi

	return 0
}

#
# Main Section: Application Data
#

main_help() {
	cat <<EOF
$BOOTY_NAME $BOOTY_VERSION

Usage: booty [DIRECTORY]
   or: booty linux [VERSION]
   or: booty ramdisk
   or: booty image SOURCE=DESTINATION...

Creates BIOS and/or UEFI compatible bootable images
with operating system from specified directory.

  -p, --profile <profile>    Creates bootable image with pre-defined options

                             Profiles:
                               initramfs [default]
                               overlayfs

  -c, --cache <directory>    Storage for data like a binary kernels, sources
                             and so on to prevent download it and building
                             the same things again and again

  --kernel-name linux,           Select kernel version to build and/or label
  --kernel-version <version>,    for cache data.
  --kernel-release <release>     

  -v, --verbose              Verbosity level can be increased by multiples -vvvvv

  --help                     Show this help

Report about bugs & features to $(echo c3Bvb2ZpbmdAdm9nbGVhLm5ldAo= | base64 -d)
EOF
}

main_init() {
	# set $TMPDIR by `mktemp` for future use
	TMPDIR="$(pwd)"
	TMPDIR="$(mktemp --directory --quiet $BOOTY_NAME-XXXXXXXXXX)"
	TMPDIR="$(realpath $TMPDIR)"

	PROFILE=""
	CACHE=""
	BOOT_IMAGE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--profile"|"-p")
				PROFILE="$2"
				shift
				;;
			"--cache"|"-c")
				CACHE="$2"
				shift
				;;
			"--help"|"-h")
				main_help | sent_message --STDOUT
				return 0
				;;
			"-"*)
				echo "Invalid option: $1" | sent_message --STDERR
				return 1
				;;
			*)
				if test -d "$1"; then
					echo "$(realpath $1)" >> "$TMPDIR/fstab"
				else
					if test "$BOOT_IMAGE" = ""; then
						BOOT_IMAGE="$1"
					else
						echo "No such directory: $1" | sent_message --STDERR
						return 1
					fi
				fi
				;;
		esac
		shift
	done

	if test "$BOOT_IMAGE"; then
		BOOT_IMAGE="$(realpath $BOOT_IMAGE)"
	else
		BOOT_IMAGE="$(pwd)/BOOT-$(uname -m).ISO"
	fi

	if test "$CACHE"; then
		if test -d "$CACHE"; then
			CACHE="$(realpath $CACHE)"
		else
			echo "No such directory: $CACHE" | sent_message --STDERR
			return 1
		fi
	fi

	case "$PROFILE" in
		"initramfs") PROFILE="initramfs" ;;
		"overlayfs") PROFILE="overlayfs" ;;
		?*)
			echo "Invalid profile: $1" | sent_message --STDERR
			return 1
			;;
		*) PROFILE="overlayfs" ;;
	esac

	#if test "$PROFILE" = "initramfs"; then
	#fi

	if test "$PROFILE" = "overlayfs"; then
		install -d "$TMPDIR/ramdisk"
		install -d "$TMPDIR/bootimg"

		linux --install-path "$TMPDIR/ramdisk" --cache "$CACHE"

		ramdisk "$TMPDIR/ramdisk" --image "$TMPDIR/ramdisk.img"

		if test -f "$TMPDIR/fstab"; then
			ORDER="0"
			while read -r SOURCE; do
				ORDER="$(($ORDER + 10))"
				DESTINATION="$ORDER-$(basename $DIRECTORY)"
				echo mksquashfs "$SOURCE" "$TMPDIR/bootimg/boot/$DESTINATION" \
					-b "1048576" \
					-comp "xz" \
					-Xdict-size "100%"
			done < "$TMPDIR/fstab"
			unset ORDER
		fi

		image "$TMPDIR/bootimg" --image "$BOOT_IMAGE" \
			"$TMPDIR/ramdisk/boot/bzImage=boot/vmlinuz" \
			"$TMPDIR/ramdisk.img=boot/initrd"
	fi
}

main_exit() {
	if test -d "$TMPDIR"; then
		echo rm -r -f "$TMPDIR"
	fi

	exit "$1"
}

main() {
	case "$1" in
		"import") shift ; do_import $@ ;;
		"export") shift ; do_export $@ ;;
		"linux") shift ; linux $@ ;;
		"linux_via_http") shift ; linux_via_http $@ ;;
		"linux_via_git") shift ; linux_via_git $@ ;;
		"linux_build") shift ; linux_build $@ ;;
		"ramdisk") shift ; ramdisk $@ ;;
		*)
			main_init $@
			main_exit 0
			;;
	esac
}

trap "do_panic" HUP INT QUIT TERM

readonly BOOTY_NAME="booty"
readonly BOOTY_VERSION="2.0"

main "$@"
