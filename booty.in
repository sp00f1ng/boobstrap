#! /usr/bin/env sh

do_error() {
	echo "$@" | sent_message --STDERR
}

do_panic() {
	do_error ""
	do_error "Interrupted"

	main_exit 1
}

do_import() {
	cpio --extract --make-directories --format "newc" --quiet
}

do_export() {
	find . -print0 | cpio --create --format "newc" --null --quiet
}

sent_message() {
	STDERR="-"
	STDOUT="+"
	INDENT=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--STDERR") STDERR="+" STDOUT="-" ;;
			"--STDOUT") STDERR="-" STDOUT="+" ;;
		esac
		shift
	done

	if test "$STDERR" = "+"; then
		while read -r MESSAGE; do
			echo "$INDENT$MESSAGE" >&2
		done
	fi

	if test "$STDOUT" = "+"; then
		while read -r MESSAGE; do
			echo "$INDENT$MESSAGE" >&1
		done
	fi
}

#
# Image Section: Bootable image
#
image() {
	INSTALL_PATH=""
	IMAGE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--image") IMAGE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1" | sent_message
				;;
			*)
				if test "$INSTALL_PATH" = ""; then
					INSTALL_PATH="$1"
				else
					break
				fi
				;;
		esac
		shift
	done

	if test "$IMAGE"; then
		IMAGE="$(realpath $IMAGE)"
	else
		echo "Image not specified, add --image <file> for initramfs image" | sent_message --STDERR
		return 1
	fi

	if test "$INSTALL_PATH"; then
		if test -d "$INSTALL_PATH"; then
			INSTALL_PATH="$(realpath $INSTALL_PATH)"
		else
			echo "No such directory: $INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		INSTALL_PATH="$(mktemp --directory --quiet image-XXXXXXXXXX)"
		INSTALL_PATH="$(realpath $INSTALL_PATH)"
	fi

	while ! test "$#" = "0"; do
		SOURCE="${1%%=*}"
		DESTINATION="${1##*=}"
		if test -f "$SOURCE"; then
			if install -D "$SOURCE" "$INSTALL_PATH/$DESTINATION"; then
				echo "[$SOURCE] [$INSTALL_PATH/$DESTINATION]" | sent_message
			fi
		fi
		shift
	done

	echo "Install bootloader" | sent_message

	image_install_bootloader "$INSTALL_PATH"

	echo "Generate ISO 9660" | sent_message

	image_generate_iso9660 "$INSTALL_PATH" "$IMAGE"
}

image_install_bootloader() {
	INSTALL_PATH="$1"

	image_search_bootloader

	image_install_grub2 "$INSTALL_PATH"
}

image_install_grub2() {
	INSTALL_PATH="$1"

	install -d "$INSTALL_PATH/boot"
	install -d "$INSTALL_PATH/boot/grub"

	cat > "$INSTALL_PATH/boot/grub/grub.cfg" <<EOF
search --file --no-floppy --set root /boot/vmlinuz
EOF

	install -d "$INSTALL_PATH/boot/grub/i386-pc"

	cp -a "$GRUB_BIOS_DATA/"*".mod" "$INSTALL_PATH/boot/grub/i386-pc"
	cp -a "$GRUB_BIOS_DATA/"*".lst" "$INSTALL_PATH/boot/grub/i386-pc"

	grub-mkimage                                        \
		                                            \
		--config="$INSTALL_PATH/boot/grub/grub.cfg" \
		--output="$INSTALL_PATH/boot/grub/core.img" \
		--format="i386-pc"                          \
		--prefix="/boot/grub"                       \
		                                            \
		"biosdisk" "iso9660" "normal" "search"      \
		"search_fs_file" "part_msdos" "part_gpt"    \
		"fat"

	cat "$GRUB_BIOS_DATA/cdboot.img" "$INSTALL_PATH/boot/grub/core.img" > "$INSTALL_PATH/boot/grub/bios.img"

	if ! test "$(id --user)" = "0"; then
		echo "You must be root to install EFI bootloader" | sent_message

		return 0
	fi

	install -d "$INSTALL_PATH/efi/boot"
	install -d "$INSTALL_PATH/boot/grub/i386-efi"
	install -d "$INSTALL_PATH/boot/grub/x86_64-efi"

	cp -a "$GRUB_EFI_LEGACY_DATA/"*".mod" "$INSTALL_PATH/boot/grub/i386-efi"
	cp -a "$GRUB_EFI_LEGACY_DATA/"*".lst" "$INSTALL_PATH/boot/grub/i386-efi"

	cp -a "$GRUB_EFI_DATA/"*".mod" "$INSTALL_PATH/boot/grub/x86_64-efi"
	cp -a "$GRUB_EFI_DATA/"*".lst" "$INSTALL_PATH/boot/grub/x86_64-efi"

	grub-mkimage                                           \
		                                               \
		--config="$INSTALL_PATH/boot/grub/grub.cfg"    \
		--output="$INSTALL_PATH/efi/boot/bootia32.efi" \
		--format="i386-efi"                            \
		--prefix="/boot/grub"                          \
		                                               \
		"iso9660" "normal" "search" "search_fs_file"   \
		"part_msdos" "part_gpt" "fat"

	grub-mkimage                                          \
		                                              \
		--config="$INSTALL_PATH/boot/grub/grub.cfg"   \
		--output="$INSTALL_PATH/efi/boot/bootx64.efi" \
		--format="x86_64-efi"                         \
		--prefix="/boot/grub"                         \
		                                              \
		"iso9660" "normal" "search" "search_fs_file"  \
		"part_msdos" "part_gpt" "fat"

	mkdosfs -C "$INSTALL_PATH/efi/boot/floppy.img" 1440

	mount -o loop "$INSTALL_PATH/efi/boot/floppy.img" "$INSTALL_PATH/boot"
	
	mkdir -p "$INSTALL_PATH/boot/efi/boot"
	
	cp "$INSTALL_PATH/efi/boot/bootx64.efi" "$INSTALL_PATH/boot/efi/boot"
	
	cp "$INSTALL_PATH/efi/boot/bootia32.efi" "$INSTALL_PATH/boot/efi/boot"
	
	umount "$INSTALL_PATH/boot"

	cat > "$INSTALL_PATH/boot/grub/grub.cfg" <<"EOF"
set default=2

function load_video {
	if [ x$feature_all_video_module = xy ]; then
		insmod all_video
	else
		insmod efi_gop
		insmod efi_uga
		insmod ieee1275_fb
		insmod vbe
		insmod vga
		insmod video_bochs
		insmod video_cirrus
	fi
}

if loadfont "unicode"; then
	set gfxmode=auto
	load_video
	insmod gfxterm
	if [ -f "$prefix/themes/default/theme.txt" ]; then
		insmod png
		set theme=$prefix/themes/default/theme.txt
	fi
fi
terminal_output gfxterm

if [ x$feature_timeout_style = xy ]; then
	set timeout_style=menu
	set timeout=3
else
	set timeout=3
fi

menuentry "Run GNU/Linux in Live-mode" {
	linux /boot/vmlinuz quiet
	initrd /boot/initrd
}
menuentry "Boot using SHMFS (default boot)" {
	linux /boot/vmlinuz booty.use-shmfs quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS" {
	linux /boot/vmlinuz booty.use-overlayfs quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Copy to RAM and release storage device)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.copy-to-ram quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Try to find /filesystem.squashfs)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.search-rootfs=/filesystem.squashfs quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Use /dev/sda as rootfs)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.search-rootfs=/dev/sda quiet
	initrd /boot/initrd
}
menuentry "Boot using Overlay FS (Use /dev/sda for data)" {
	linux /boot/vmlinuz booty.use-overlayfs booty.rootfs-changes=/dev/sda quiet
	initrd /boot/initrd
}
EOF
}

image_install_syslinux() {
	# TODO syslinux
	# FIXME syslinux: legacy boot + gpt is just broken on ~May 2020
	return 1
}

image_search_bootloader() {
	for dir in "/usr/lib/grub" "/lib/grub"; do
		if test -d "$dir/i386-pc"; then
			GRUB_BIOS_DATA="$dir/i386-pc"
		fi
		if test -d "$dir/i386-efi"; then
			GRUB_EFI_LEGACY_DATA="$dir/i386-efi"
		fi
		if test -d "$dir/x86_64-efi"; then
			GRUB_EFI_DATA="$dir/x86_64-efi"
		fi
	done
	for dir in "/usr/share/syslinux" "/usr/lib/syslinux/bios"; do
		if test -f "$dir/mbr.bin"; then
			SYSLINUX_BIOS_MBR="$dir/mbr.bin"
		fi
		if test -f "$dir/gptmbr.bin"; then
			SYSLINUX_BIOS_GPTMBR="$dir/gptmbr.bin"
		fi
		if test -f "$dir/isolinux.bin"; then
			SYSLINUX_BIOS_ISOLINUX="$dir/isolinux.bin"
		fi
		if test -f "$dir/ldlinux.c32"; then
			SYSLINUX_BIOS_LDLINUX="$dir/ldlinux.c32"
		fi
	done
	for dir in "/usr/share/syslinux/efi64" "/usr/lib/syslinux/efi64"; do
		if test -f "$dir/syslinux.efi"; then
			SYSLINUX_UEFI_EFIBOOT="$dir/syslinux.efi"
		fi
		if test -f "$dir/ldlinux.e64"; then
			SYSLINUX_UEFI_LDLINUX="$dir/ldlinux.e64"
		fi
	done
	unset dir
}

image_generate_iso9660() {
	INSTALL_PATH="$1"
	IMAGE="$2"
	COMMAND=""

	if test "$COMMAND" = ""; then
		if command -v "xorrisofs"; then
			COMMAND="xorrisofs"
		fi

		if command -v "genisoimage"; then
			COMMAND="genisoimage"
		fi
	else
		echo "Install one: cdrkit, xorriso, mkisofs" | sent_message
		return 1
	fi

	if test "$COMMAND" = "genisoimage"; then
		genisoimage -v -J -r -V "BOOT-$(uname -m)" -A "BOOT-$(uname -m)" \
			-input-charset "utf-8" \
			-b "boot/grub/bios.img" -no-emul-boot -boot-load-size 4 -boot-info-table \
			-eltorito-alt-boot -e "efi/boot/floppy.img" -no-emul-boot \
			-o "$IMAGE" "$INSTALL_PATH"
	fi

	if test "$COMMAND" = "xorrisofs"; then
		# TODO
		return 1
	fi
	return 0
}

#
# Initial RAM Disk Section: Build initramfs
#

ramdisk() {
	INSTALL_PATH=""
	IMAGE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--install-path") INSTALL_PATH="$2" ; shift ;;
			"--image") IMAGE="$2" ; shift ;;
			"-"*)
				echo "invalid option $1" | sent_message
				;;
			*)
				if test "$INSTALL_PATH" = ""; then
					INSTALL_PATH="$1"
				fi
				;;
		esac
		shift
	done

	if test "$IMAGE"; then
		IMAGE="$(realpath $IMAGE)"
	else
		echo "Image not specified, add --image <file> for initramfs image" | sent_message --STDERR
		return 1
	fi

	if test "$INSTALL_PATH"; then
		if test -d "$INSTALL_PATH"; then
			ROOT="$(realpath $INSTALL_PATH)"
		else
			echo "No such directory: $INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		ROOT="$(mktemp --directory --quiet ramdisk-XXXXXXXXXX)"
		ROOT="$(realpath $ROOT)"
	fi

	ramdisk_make_directories "$ROOT"

	ramdisk_make_devices "$ROOT"

	ramdisk_make_binaries "$ROOT"

	install -D -m 0755 "/usr/share/booty/init.rc" "$ROOT/init"

	cd "$ROOT"

	do_export > "$IMAGE"
	
	cd "$OLDPWD"

	return 0
}

ramdisk_make_directories() {
	for dir in "/proc" "/sys" "/dev" "/run" "/sbin" "/bin" "/etc" "/usr/sbin" "/usr/bin" "/mnt" "/tmp"; do
		mkdir -p "$1/$dir" || return 1
	done
	
	unset dir
	
	return 0
}

ramdisk_make_devices() {
	for dev in "console" "tty" "tty1" "null"; do
		cp -a "/dev/$dev" "$1/dev/$dev" || return 1
	done

	return 0
}

lddtree() {
	if test "$1" = ""; then
		return 0
	fi
	
	echo "$1"
	
	for dep in $(ldd "$1" | awk 'BEGIN{ORS="\n"}$1~/^\//{print $1}$3~/^\//{print $3}'); do
		lddtree "$dep"
	done
	
	unset dep
}

ramdisk_make_binaries() {
	for exe in "sh" "env" "switch_root" "mount" "umount" "mkdir" "rmdir" "cp" "mv" "rm" "mknod" "cpio" "sleep"; do
		LOCATE_EXE="$(which $exe)"

		if test "$LOCATE_EXE"; then
			LOCATE_DEP=""

			for dep in $(lddtree $LOCATE_EXE); do
				LOCATE_DEP="$LOCATE_DEP $dep"

				if test -f "$1/$dep"; then
					continue
				fi

				install -D "$dep" "$1/$dep" || return 1
			done

			unset dep
		fi
	done

	return 0
}

#
# Linux Section: Download & Build
#

download() {
	URL="$1"
	DIRECTORY="$2"
	FILE="$3"
	APPEND=""

	if ! test -d "$DIRECTORY"; then
		return 1
	fi

	if test -f "$DIRECTORY/$FILE"; then
		return 1
	fi

	if test -f "$DIRECTORY/$FILE.part"; then
		APPEND="--continue"
	fi

	wget --timeout 5 --output-document="$DIRECTORY/$FILE.part" $APPEND --quiet "$URL" || return 1

	mv "$DIRECTORY/$FILE.part" "$DIRECTORY/$FILE" || return 1

	return 0
}

extract() {
	DESTINATION="$1"
	DIRECTORY="$2"
	FILE="$3"

	if ! test -d "$DESTINATION"; then
		return 1
	fi

	if ! test -d "$DIRECTORY"; then
		return 1
	fi

	if ! test -f "$DIRECTORY/$FILE"; then
		return 1
	fi

	if ! tar --get --file="$DIRECTORY/$FILE" --directory="$DESTINATION"; then
		return 1
	fi

	return 0
}

linux() {
	__KERNEL_NAME=""
	__KERNEL_VERSION=""
	__KERNEL_RELEASE=""
	__CONFIG_FILE=""
	__INSTALL_PATH=""
	__FORCE=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") __KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") __KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") __KERNEL_RELEASE="$2" ; shift ;;
			"--config-file") __CONFIG_FILE="$2" ; shift ;;
			"--install-path") __INSTALL_PATH="$2" ; shift ;;
			"--force") __FORCE="+" ;;
			"-"*) echo "Invalid option: $1" | sent_message --STDERR ; return 1 ;;
			*) echo "Invalid string: $1" | sent_message --STDERR ; return 1 ;;
		esac
		shift
	done

	if test "$CONFIG_KERNEL_VERSION" = "stable"; then
		CONFIG_KERNEL_VERSION="$(linux_via_http_get_version)"

		if test "$CONFIG_KERNEL_VERSION" = "hacked"; then
			echo "kernel.org was hacked" | sent_message --STDERR
			return 1
		fi
	fi

	if test "$__KERNEL_NAME" = ""; then
		__KERNEL_NAME="$CONFIG_KERNEL_NAME"
	fi
	if test "$__KERNEL_VERSION" = ""; then
		__KERNEL_VERSION="$CONFIG_KERNEL_VERSION"
	fi
	if test "$__KERNEL_RELEASE" = ""; then
		__KERNEL_RELEASE="$CONFIG_KERNEL_RELEASE"
	fi

	if test "$__CONFIG_FILE"; then
		if test -f "$__CONFIG_FILE"; then
			__CONFIG_FILE="$(realpath $__CONFIG_FILE)"

			V_CONFIG_FILE_HASH="$(md5sum $__CONFIG_FILE)"
			V_CONFIG_FILE_HASH="${V_CONFIG_FILE_HASH%% *}"

			CONFIG_KERNEL_RELEASE="$V_CONFIG_FILE_HASH"
		else
			echo "No such file: $__CONFIG_FILE" | sent_message --STDERR
			return 1
		fi
	fi

	if test "$__INSTALL_PATH"; then
		if test -d "$__INSTALL_PATH"; then
			__INSTALL_PATH="$(realpath $__INSTALL_PATH)"
		else
			echo "No such directory: $__INSTALL_PATH" | sent_message --STDERR
			return 1
		fi
	else
		__INSTALL_PATH="$(mktemp --directory --quiet root-XXXXXXXXXX)"
		__INSTALL_PATH="$(realpath $__INSTALL_PATH)"
	fi

	if test "$__FORCE"; then
		__FORCE_DOWNLOAD="--force-download"
		__FORCE_REBUILD="--force-rebuild"
	else
		__FORCE_DOWNLOAD=""
		__FORCE_REBUILD=""

		if test -f "$CONFIG_CACHE_PATH/$__KERNEL_NAME-$__KERNEL_RELEASE#$__KERNEL_VERSION.pkg.tar"; then
			extract "$__INSTALL_PATH" "$CONFIG_CACHE_PATH" "$__KERNEL_NAME-$__KERNEL_RELEASE#$__KERNEL_VERSION.pkg.tar"
			return 0
		fi
	fi

	linux_via_http                               \
		--kernel-name "$__KERNEL_NAME"       \
		--kernel-version "$__KERNEL_VERSION" \
		--kernel-release "$__KERNEL_RELEASE" \
		$__FORCE_DOWNLOAD                    \
		|| return 1

	linux_build                                  \
		--kernel-name "$__KERNEL_NAME"       \
		--kernel-version "$__KERNEL_VERSION" \
		--kernel-release "$__KERNEL_RELEASE" \
		--build-path "$V_BUILD_PATH"         \
		--config-file "$__CONFIG_FILE"       \
		--install-path "$__INSTALL_PATH"     \
		$__FORCE_REBUILD                     \
		|| return 1

	if test -f "$__INSTALL_PATH/lib/modules/$__KERNEL_VERSION/vmlinuz"; then
		tar --create --file="$CONFIG_CACHE_PATH/$__KERNEL_NAME-$__KERNEL_RELEASE#$__KERNEL_VERSION.pkg.tar" --directory="$__INSTALL_PATH" "."
	fi

	return 0
}

linux_via_http_get_version() {
	V_KERNEL_VERSION=$(wget --timeout 5 --output-document - --quiet www.kernel.org | grep -A 1 latest_link)
	V_KERNEL_VERSION=${V_KERNEL_VERSION##*.tar.xz\">}
	V_KERNEL_VERSION=${V_KERNEL_VERSION%</a>*}

	case "$V_KERNEL_VERSION" in
		[0-9]*.[0-9]*.0)
			V_KERNEL_VERSION="${V_KERNEL_VERSION%.*}"
			echo "$V_KERNEL_VERSION"
			return 0
			;;
		[0-9]*.[0-9]*.[0-9]*)
			echo "$V_KERNEL_VERSION"
			return 0
			;;
	esac

	echo "hacked"
	return 1
}

linux_via_http() {
	__KERNEL_NAME=""
	__KERNEL_VERSION=""
	__KERNEL_RELEASE=""
	__FORCE_DOWNLOAD=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") __KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") __KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") __KERNEL_RELEASE="$2" ; shift ;;
			"--force-download") __FORCE_DOWNLOAD="+" ;;
			"-"*) echo "Invalid option: $1" | sent_message --STDERR ; return 1 ;;
			*) echo "Invalid string: $1" | sent_message --STDERR ; return 1 ;;
		esac
		shift
	done

	V_LOCAL_DIRECTORY="$CONFIG_BUILD_PATH"
	V_LOCAL_FILE="$__KERNEL_NAME-$__KERNEL_VERSION.tar.xz"

	V_REMOTE_DIRECTORY="/pub/$__KERNEL_NAME/kernel/v${__KERNEL_VERSION%%.*}.x"
	V_REMOTE_FILE="$__KERNEL_NAME-$__KERNEL_VERSION.tar.xz"

	V_URL="https://cdn.kernel.org$V_REMOTE_DIRECTORY/$V_REMOTE_FILE"
	V_BUILD_PATH="$V_LOCAL_DIRECTORY/$__KERNEL_NAME-$__KERNEL_VERSION"

	if test -f "$V_LOCAL_DIRECTORY/$V_LOCAL_FILE"; then

		rm -f "$V_LOCAL_DIRECTORY/$V_LOCAL_FILE"

	fi

	if test -d "$V_BUILD_PATH"; then

		rm -r -f "$V_BUILD_PATH"

	fi

	if test "$__FORCE_DOWNLOAD"; then

		download "$V_URL" "$V_LOCAL_DIRECTORY" "$V_LOCAL_FILE" || return 1

		extract "$V_LOCAL_DIRECTORY" "$V_LOCAL_DIRECTORY" "$V_LOCAL_FILE" || return 1

		install -D "$V_LOCAL_DIRECTORY/$V_LOCAL_FILE" "$CONFIG_CACHE_PATH/$V_LOCAL_FILE"

	elif test -f "$CONFIG_CACHE_PATH/$V_LOCAL_FILE"; then

		extract "$V_LOCAL_DIRECTORY" "$CONFIG_CACHE_PATH" "$V_LOCAL_FILE" || return 1

	elif test -f "$V_LOCAL_DIRECTORY/$V_LOCAL_FILE"; then

		extract "$V_LOCAL_DIRECTORY" "$V_LOCAL_DIRECTORY" "$V_LOCAL_FILE" || return 1

	else

		download "$V_URL" "$V_LOCAL_DIRECTORY" "$V_LOCAL_FILE" || return 1

		extract "$V_LOCAL_DIRECTORY" "$V_LOCAL_DIRECTORY" "$V_LOCAL_FILE" || return 1

		install -D "$V_LOCAL_DIRECTORY/$V_LOCAL_FILE" "$CONFIG_CACHE_PATH/$V_LOCAL_FILE"
	fi

	if test -d "$V_BUILD_PATH"; then

		return 0

	fi

	return 1
}

linux_build() {
	__KERNEL_NAME=""
	__KERNEL_VERSION=""
	__KERNEL_RELEASE=""
	__BUILD_PATH=""
	__CONFIG_FILE=""
	__INSTALL_PATH=""
	__FORCE_REBUILD=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--kernel-name") __KERNEL_NAME="$2" ; shift ;;
			"--kernel-version") __KERNEL_VERSION="$2" ; shift ;;
			"--kernel-release") __KERNEL_RELEASE="$2" ; shift ;;
			"--build-path") __BUILD_PATH="$2" ; shift ;;
			"--config-file") __CONFIG_FILE="$2" ; shift ;;
			"--install-path") __INSTALL_PATH="$2" ; shift ;;
			"--force-rebuild") __FORCE_REBUILD="+" ;;
			"-"*) echo "Invalid option: $1" | sent_message --STDERR ; return 1 ;;
			*) echo "Invalid string: $1" | sent_message --STDERR ; return 1 ;;
		esac
		shift
	done

	cd "$__BUILD_PATH"

	if test -f "$__CONFIG_FILE"; then
		
		install -D "$__CONFIG_FILE" "$__BUILD_PATH/.config"

		make olddefconfig

	else

		make defconfig

		make kvm_guest.config

		# SquashFS + OverlayFS
		scripts/config -e OVERLAY_FS

		scripts/config -e SQUASHFS
		scripts/config -e SQUASHFS_XZ

		make olddefconfig

	fi

	make -j $(($(nproc) + 1))

	make INSTALL_MOD_PATH="$__INSTALL_PATH" modules_install

	install -D "$__BUILD_PATH/arch/x86/boot/bzImage" "$__INSTALL_PATH/lib/modules/$__KERNEL_VERSION/vmlinuz" || return 1

	return 0
}

#
# Main Section: Application Data
#

main_help() {
	cat <<EOF
$BOOTY_NAME $BOOTY_VERSION

Usage: booty build <IMAGE> [DIRECTORY]...

Creates BIOS and/or UEFI compatible bootable images
with operating system from specified directory.

  -p, --profile <profile>    Creates bootable image with pre-defined options

                             Profiles:
                               initramfs
                               overlayfs [default]

  --help                     Show this help

Example: booty build boot-$(uname -m).iso linux-install/ documents-and-settings/

         booty build tiny-$(uname -m).iso linux-minimal/ --profile initramfs

EOF
}

main_init() {
	TMPDIR="$(pwd)"
	TMPDIR="$(mktemp --directory --quiet $BOOTY_NAME-XXXXXXXXXX)"
	TMPDIR="$(realpath $TMPDIR)"

	_IMAGE_=""
	__PROFILE=""
	V_FILESYSTEM=""

	while ! test "$#" = "0"; do
		case "$1" in
			"--profile"|"-p") __PROFILE="$2" ; shift ;;
			"--help") main_help ; return 0 ;;
			"-"*) echo "Invalid option: $1" | sent_message --STDERR ; return 1 ;;
			*)
				if test "$_IMAGE_" = ""; then
					case "$1" in
						*"."[Ii][Ss][Oo]) _IMAGE_="$(realpath $1)" ;;
						*"."[Ii][Mm][Gg]) _IMAGE_="$(realpath $1)" ;;
						*) echo "Invalid image: $1" | sent_message --STDERR ; return 1 ;;
					esac
				elif test -d "$1"; then
					V_FILESYSTEM="$V_FILESYSTEM:$(realpath $1)"
				else
					echo "No such directory: $1" | sent_message --STDERR
					return 1
				fi
				;;
		esac
		shift
	done

	case "$__PROFILE" in
		"initramfs") __PROFILE="initramfs" ;;
		"overlayfs") __PROFILE="overlayfs" ;;
		?*) echo "Invalid profile: $__PROFILE" | sent_message --STDERR ; return 1 ;;
		*) __PROFILE="overlayfs" ;;
	esac

	if test "$PROFILE" = "overlayfs"; then
		linux

		ramdisk --image "$TMPDIR/ramdisk.img"

		if test "$V_FILESYSTEM"; then

			V_ORDER="0"

			IFS=":"

			for V_SOURCE in "$V_FILESYSTEM"; do

				V_ORDER="$(($V_ORDER + 10))"
				V_DESTINATION="$V_ORDER-$(basename $V_SOURCE)"

				/usr/bin/env mksquashfs                      \
					"$V_SOURCE" "$TMPDIR/$V_DESTINATION" \
					-b "1048576"                         \
					-comp "xz"                           \
					-Xdict-size "100%"

			done

			unset IFS
		fi

		image --image "$BOOT_IMAGE" \
			"$TMPDIR/ramdisk/boot/bzImage=boot/vmlinuz" \
			"$TMPDIR/ramdisk.img=boot/initrd"
	fi
}

main_exit() {
	if test -d "$TMPDIR"; then
		echo rm -r -f "$TMPDIR"
	fi

	exit "$1"
}

main() {
	test "$CONFIG_BUILD_PATH" || CONFIG_BUILD_PATH="$(pwd)"
	test "$CONFIG_CACHE_PATH" || CONFIG_CACHE_PATH="$XDG_CACHE_HOME"

	test "$CONFIG_KERNEL_NAME"    || CONFIG_KERNEL_NAME="linux"
	test "$CONFIG_KERNEL_VERSION" || CONFIG_KERNEL_VERSION="stable"
	test "$CONFIG_KERNEL_RELEASE" || CONFIG_KERNEL_RELEASE="default"

	if test "$CONFIG_CACHE_PATH" = ""; then
		CONFIG_CACHE_PATH="$HOME/.cache/booty"

		install -d "$CONFIG_CACHE_PATH"
	fi

	case "$1" in
		"build") main_init $@ ; main_exit 0 ;;
		"import") shift ; do_import $@ ;;
		"export") shift ; do_export $@ ;;
		"linux") shift ; linux $@ ;;
		"ramdisk") shift ; ramdisk $@ ;;
		"image") shift ; image $@ ;;
		"run") shift ; $@ ;;
		"") main_help ;;
	esac
}

readonly BOOTY_NAME="booty"
readonly BOOTY_VERSION="2.0"

trap "do_panic" HUP INT QUIT TERM

main "$@"
